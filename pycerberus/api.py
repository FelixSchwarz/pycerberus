# -*- coding: UTF-8 -*-

import inspect

from pycerberus.errors import EmptyError, InvalidArgumentsError, InvalidDataError
from pycerberus.i18n import _, GettextTranslation
from pycerberus.lib import SuperProxy

__all__ = ['BaseValidator', 'Validator']


class NoValueSet(object):
    pass


class EarlyBindForMethods(type):
    def __new__(cls, classname, direct_superclasses, class_attributes_dict):
        validator_class = type.__new__(cls, classname, direct_superclasses, class_attributes_dict)
        cls._simulate_early_binding_for_message_methods(validator_class)
        return validator_class
    
    @classmethod
    def _simulate_early_binding_for_message_methods(cls, validator_class):
        # We need to simulate 'early binding' so that we can reference the 
        # messages() method which is defined in the class to be created!
        def keys(self):
            return validator_class.messages(self)
        validator_class.keys = keys
        
        if validator_class.__name__ == 'BaseValidator' or \
            getattr(validator_class.message_for_key, 'autogenerated', False):
            def message_for_key(self, key, state):
                return validator_class.messages(self)[key]
            message_for_key.autogenerated = True
            validator_class.message_for_key = message_for_key


class BaseValidator(object):
    """The BaseValidator implements only the minimally required methods. Most
    users probably want to use the Validator class which already implements some
    commonly used features."""
    
    __metaclass__ = EarlyBindForMethods
    super = SuperProxy()
    
    def messages(self):
        return {}
    
    def message_for_key(self, key, state):
        """Message for key allows you to avoid a call to messages() which comes
        handy when you have a lot of messages and returning them is expensive."""
        raise NotImplementedError('message_for_key() should have been replaced by a metaclass')
    
    def keys(self):
        raise NotImplementedError('keys() should have been replaced by a metaclass')
    
    def error(self, key, value, state):
        msg = self.message_for_key(key, state)
        raise InvalidDataError(msg, value, key, state)
    
    def process(self, value, state=None):
        return value
    
    def as_string(self, value, state=None):
        "Return the value as string"
        return str(value)


class Validator(BaseValidator):
    def __init__(self, default=NoValueSet, required=NoValueSet, *args, **kwargs):
        """The Validator is the base class of most validators and implements 
        some commonly used features like required values (raise exception if no
        value was provided) or default values in case no value is given.
        
        In this validator, validation and conversion are packed together because
        experience showed that both operations are often very tightly coupled
        in order not to duplicate code (validation already performs a conversion,
        conversion on unvalidated values is unsafe or there are different types
        of valid input so both validation and conversion need to know about the
        algorithm). And last but not least, using real Python types (e.g. int(5)
        instead of '5') is much more convenient...
        
        When a value is processed, the validator will first call convert() which
        performce some checks on the value and eventually returns the converted
        value. After that the validate() function can do additional checks on
        the converted value and possibly raise an Exception on errors.
        
        By default, a validator will raise an InvalidDataError if no value was
        given (unless you set a default value). If required is False, the 
        default is None.
        
        In order to prevent programmer errors, an exception will be raised if 
        you set required to True but provide a default value as well.
        
        All exceptions thrown by validators must be derived from ValidationError.
        Exceptions caused by invalid user input should use InvalidDataError or
        one of the subclasses."""
        self.super()
        self._default = default
        self._required = required
        self._check_argument_consistency()
        self._implementations, self._implementation_by_class = self._freeze_implementations_for_class()
    
    # --------------------------------------------------------------------------
    # initialization
    
    def _check_argument_consistency(self):
        if self.is_required(set_explicitely=True) and self._has_default_value_set():
            msg = 'Set default value (%s) has no effect because a value is required.' % repr(self._default)
            raise InvalidArgumentsError(msg)
    
    def _has_default_value_set(self):
        return (self._default is not NoValueSet)
    
    def _freeze_implementations_for_class(self):
        class_for_key = {}
        implementations_for_class = {}
        known_functions = set()
        for cls in reversed(inspect.getmro(self.__class__)):
            if self._class_defines_custom_keys(cls, known_functions):
                known_functions.add(cls.keys)
                for key in cls.keys(self):
                    class_for_key[key] = self._implementations_by_key(cls)
                    implementations_for_class[cls] = class_for_key[key]
        return class_for_key, implementations_for_class
    
    def _implementations_by_key(self, cls):
        implementations_by_key = dict()
        for name in ['translation_parameters', 'keys', 'message_for_key', 'translate_message']:
            implementations_by_key[name] = getattr(cls, name)
        return implementations_by_key
    
    def _class_defines_custom_keys(self, cls, known_functions):
        return hasattr(cls, 'keys') and cls.keys not in known_functions
    
    # --------------------------------------------------------------------------
    # Implementation of BaseValidator API
    
    def messages(self):
        return {'empty': _('Value must not be empty.')}
    
    def error(self, key, value, state, errorclass=InvalidDataError, **values):
        translated_message = self.message(key, state, **values)
        raise errorclass(translated_message, value, key=key, state=state)
    
    def process(self, value, state=None):
        """Apply the validator on value and return the validated value. Raise 
        an InvalidDataError if the input is malformed.
        You can provide a dictionary to make the validator aware of some 
        external state (e.g. current user). This state object is passed to all
        other methods which can be implemented by subclasses. If you don't 
        provide any state, an emtpy dict will be used instead.
        
        Use this method to sanitize input data
        """
        if state is None:
            state = {}
        value = super(Validator, self).process(value, state)
        if self.is_empty(value, state) == True:
            if self.is_required() == True:
                self.error('empty', value, state, errorclass=EmptyError)
            return self.empty_value(state)
        converted_value = self.convert(value, state)
        self.validate(converted_value, state)
        return converted_value
    
    # --------------------------------------------------------------------------
    # Defining a convenience API
    
    def convert(self, value, state):
        """Convert the input value to a suitable Python instance which is 
        returned. If the input is invalid, raise an InvalidDataError."""
        return value
   
    def validate(self, converted_value, state):
        """Perform additional checks on the value which was processed 
        successfully before (otherwise this method is not called). Raise an 
        InvalidDataError if the input data is invalid.
        
        This method must not modify the converted_value."""
        pass
    
    def empty_value(self, state):
        """Return the 'empty' value for this validator."""
        if self._default is NoValueSet:
            return None
        return self._default
    
    def is_empty(self, value, state):
        """Decide if the value is considered an empty value."""
        return (value is None)
    
    def is_required(self, set_explicitely=False):
        if self._required == True:
            return True
        elif (not set_explicitely) and (self._required == NoValueSet):
            return True
        return False
    
    # -------------------------------------------------------------------------
    # i18n: public API
    
    def translation_parameters(self, state):
        return {'domain': 'pycerberus'}
    
    def translate_message(self, key, native_message, translation_parameters, state):
        # This method can be overridden on a by-class basis to get translations 
        # to support non-gettext translation mechanisms (e.g. from a db)
        return GettextTranslation(**translation_parameters).gettext(native_message)
    
    def message(self, key, state, **values):
        # This method can be overridden globally to use a different message 
        # lookup / translation mechanism altogether
        native_message = self._implementation(key, 'message_for_key', state)(key)
        translation_parameters = self._implementation(key, 'translation_parameters', state)()
        translation_function = self._implementation(key, 'translate_message', state)
        translated_template = translation_function(key, native_message, translation_parameters)
        return translated_template % values
    
    # -------------------------------------------------------------------------
    # private 
    
    def _implementation(self, key, methodname, state):
        def state_key_wrapper(*args):
            method = self._implementations[key][methodname]
            args = list(args) + [state]
            return method(self, *args)
        return state_key_wrapper
    # -------------------------------------------------------------------------


